{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"mempool \u2013 Deterministic Memory Pool Library","text":"<p>mempool is a small, portable memory pool library written in C11.</p> <p>It is designed for embedded and safety-related systems that need:</p> <ul> <li>deterministic, fixed-size allocation and free,</li> <li>no use of <code>malloc</code> / <code>free</code>,</li> <li>explicit control over where state and buffers live,</li> <li>a simple API that works on bare metal and hosted targets.</li> </ul> <p>The project uses:</p> <ul> <li>an opaque <code>mempool_t</code> state object stored in caller-provided memory,</li> <li>a caller-provided pool buffer that holds all allocation blocks,</li> <li>O(1) allocation and deallocation using a free list and bitmap,</li> <li>error codes for every failure path,</li> <li>optional hooks for integrating with a locking primitive on multi-threaded systems.</li> </ul> <p>The repository is structured so it can fit into more formal processes (e.g. ISO 26262\u2013style), without requiring commercial tooling.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Deterministic fixed-size block allocator</li> <li>Caller-owned state and pool memory (no dynamic allocation)</li> <li>Configurable block size and alignment</li> <li>Error codes (<code>mempool_error_t</code>) for all failure modes</li> <li>Statistics (<code>mempool_stats_t</code>) for usage monitoring</li> <li>Optional synchronization hooks for multi-threaded platforms</li> <li>C test harness + GoogleTest-based C++ tests (including multithreaded tests)</li> <li>CI with sanitizers and static analysis (cppcheck)</li> </ul>"},{"location":"#where-to-start","title":"Where to Start","text":"<ul> <li>Quick Start \u2013 minimal example and usage pattern</li> <li>Building \u2013 building on host, running tests, enabling sanitizers</li> <li>API Reference \u2013 complete description of the public API</li> <li>Safety &amp; Process \u2013 requirements, traceability, and safety documentation</li> </ul> <p>If you simply want to see it in action, check out the Examples:</p> <ul> <li>Basic Usage</li> <li>Embedded</li> <li>Stress &amp; Testing</li> </ul>"},{"location":"api-core/","title":"API Reference \u2013 Core Functions","text":"<p>This page lists the core functions exposed by the library.</p> <p>All functions return a <code>mempool_error_t</code> unless documented otherwise. Callers should check the return value of every function.</p>"},{"location":"api-core/#size_t-mempool_state_sizevoid","title":"<code>size_t mempool_state_size(void);</code>","text":"<p>Returns the number of bytes required to hold the internal <code>mempool_t</code> state.</p> <pre><code>size_t mempool_state_size(void);\n</code></pre> <p>Typical usage:</p> <pre><code>size_t needed = mempool_state_size();\nif (needed &gt; MEMPOOL_STATE_SIZE) {\n    /* Configuration error: increase MEMPOOL_STATE_SIZE */\n}\n</code></pre>"},{"location":"api-core/#mempool_init","title":"<code>mempool_init</code>","text":"<p>Initializes a memory pool in caller-provided storage.</p> <pre><code>mempool_error_t mempool_init(\n    void        *state_buffer,\n    size_t       state_buffer_size,\n    void        *pool_buffer,\n    size_t       pool_buffer_size,\n    size_t       block_size,\n    size_t       alignment,\n    mempool_t  **pool_out);\n</code></pre>"},{"location":"api-core/#parameters","title":"Parameters","text":"<ul> <li> <p><code>state_buffer</code>   Pointer to the state buffer (must be at least <code>mempool_state_size()</code> bytes).</p> </li> <li> <p><code>state_buffer_size</code>   Size of <code>state_buffer</code> in bytes.</p> </li> <li> <p><code>pool_buffer</code>   Pointer to the pool buffer that will hold all blocks.</p> </li> <li> <p><code>pool_buffer_size</code>   Size of <code>pool_buffer</code> in bytes.</p> </li> <li> <p><code>block_size</code>   Size of each allocation block in bytes (must be at least <code>sizeof(void*)</code>, typically larger).</p> </li> <li> <p><code>alignment</code>   Alignment requirement for blocks and <code>pool_buffer</code> (must be a power of two).</p> </li> <li> <p><code>pool_out</code>   Output parameter; on success, set to a valid <code>mempool_t*</code> handle.</p> </li> </ul>"},{"location":"api-core/#returns","title":"Returns","text":"<ul> <li><code>MEMPOOL_OK</code> on success.</li> <li><code>MEMPOOL_ERR_NULL_PTR</code> if any required pointer is <code>NULL</code>.</li> <li><code>MEMPOOL_ERR_INVALID_SIZE</code> if sizes are invalid or no block can fit.</li> <li><code>MEMPOOL_ERR_ALIGNMENT</code> if alignment is invalid or the pool buffer is misaligned.</li> </ul>"},{"location":"api-core/#mempool_alloc","title":"<code>mempool_alloc</code>","text":"<p>Allocates a single block from the pool.</p> <pre><code>mempool_error_t mempool_alloc(mempool_t *pool, void **block);\n</code></pre>"},{"location":"api-core/#parameters_1","title":"Parameters","text":"<ul> <li><code>pool</code> \u2013 Pool handle returned by <code>mempool_init</code>.</li> <li><code>block</code> \u2013 Output pointer to receive the allocated block.</li> </ul>"},{"location":"api-core/#returns_1","title":"Returns","text":"<ul> <li><code>MEMPOOL_OK</code> on success; <code>*block</code> will be non-<code>NULL</code>.</li> <li><code>MEMPOOL_ERR_OUT_OF_MEMORY</code> if the pool is exhausted.</li> <li><code>MEMPOOL_ERR_NULL_PTR</code> if <code>pool</code> or <code>block</code> is <code>NULL</code>.</li> <li><code>MEMPOOL_ERR_NOT_INITIALIZED</code> if the pool was not properly initialized.</li> </ul> <p>The operation is O(1).</p>"},{"location":"api-core/#mempool_free","title":"<code>mempool_free</code>","text":"<p>Frees a previously allocated block back to the pool.</p> <pre><code>mempool_error_t mempool_free(mempool_t *pool, void *block);\n</code></pre>"},{"location":"api-core/#parameters_2","title":"Parameters","text":"<ul> <li><code>pool</code> \u2013 Pool handle returned by <code>mempool_init</code>.</li> <li><code>block</code> \u2013 Pointer to a block obtained from <code>mempool_alloc</code>.</li> </ul>"},{"location":"api-core/#returns_2","title":"Returns","text":"<ul> <li><code>MEMPOOL_OK</code> on success.</li> <li><code>MEMPOOL_ERR_NULL_PTR</code> if <code>pool</code> or <code>block</code> is <code>NULL</code>.</li> <li><code>MEMPOOL_ERR_NOT_INITIALIZED</code> if the pool is not initialized.</li> <li><code>MEMPOOL_ERR_INVALID_BLOCK</code> if <code>block</code> does not belong to this pool or is misaligned.</li> <li><code>MEMPOOL_ERR_DOUBLE_FREE</code> if the block has already been freed.</li> </ul> <p>The library performs bounds and alignment checks and uses a bitmap to detect double-free attempts.</p>"},{"location":"api-core/#mempool_get_stats","title":"<code>mempool_get_stats</code>","text":"<p>Retrieves current usage statistics.</p> <pre><code>mempool_error_t mempool_get_stats(const mempool_t *pool,\n                                  mempool_stats_t *stats);\n</code></pre>"},{"location":"api-core/#parameters_3","title":"Parameters","text":"<ul> <li><code>pool</code> \u2013 Pool handle.</li> <li><code>stats</code> \u2013 Output structure to receive statistics.</li> </ul>"},{"location":"api-core/#returns_3","title":"Returns","text":"<ul> <li><code>MEMPOOL_OK</code> on success.</li> <li><code>MEMPOOL_ERR_NULL_PTR</code> if <code>pool</code> or <code>stats</code> is <code>NULL</code>.</li> <li><code>MEMPOOL_ERR_NOT_INITIALIZED</code> if the pool is not initialized.</li> </ul>"},{"location":"api-core/#mempool_reset","title":"<code>mempool_reset</code>","text":"<p>Resets a pool to its initial state.</p> <pre><code>mempool_error_t mempool_reset(mempool_t *pool);\n</code></pre>"},{"location":"api-core/#behavior","title":"Behavior","text":"<ul> <li>All blocks become free.</li> <li>Statistics are reset (usage, peak, alloc/free counts).</li> <li>All existing pointers previously returned by <code>mempool_alloc</code> become invalid.   Passing them to <code>mempool_free</code> after a reset results in <code>MEMPOOL_ERR_DOUBLE_FREE</code>.</li> </ul>"},{"location":"api-core/#returns_4","title":"Returns","text":"<ul> <li><code>MEMPOOL_OK</code> on success.</li> <li><code>MEMPOOL_ERR_NULL_PTR</code> if <code>pool</code> is <code>NULL</code>.</li> <li><code>MEMPOOL_ERR_NOT_INITIALIZED</code> if the pool is not initialized.</li> </ul>"},{"location":"api-core/#mempool_contains","title":"<code>mempool_contains</code>","text":"<p>Checks whether a pointer lies within the pool\u2019s managed block region.</p> <pre><code>bool mempool_contains(const mempool_t *pool, const void *ptr);\n</code></pre>"},{"location":"api-core/#returns_5","title":"Returns","text":"<ul> <li><code>true</code> if <code>ptr</code> is within the range of blocks managed by <code>pool</code>.</li> <li><code>false</code> otherwise, or if <code>pool</code> is <code>NULL</code> or not initialized.</li> </ul> <p>This function does not check whether the block is currently allocated or free, only whether it belongs to the pool.</p>"},{"location":"api-core/#mempool_strerror","title":"<code>mempool_strerror</code>","text":"<p>Returns a human-readable string for a <code>mempool_error_t</code> value.</p> <pre><code>const char *mempool_strerror(mempool_error_t error);\n</code></pre> <p>The returned pointer refers to a static string that must not be modified or freed.</p> <p>Example:</p> <pre><code>mempool_error_t err = mempool_alloc(pool, &amp;block);\nif (err != MEMPOOL_OK) {\n    printf(\"mempool_alloc failed: %s\\n\", mempool_strerror(err));\n}\n</code></pre>"},{"location":"api-sync/","title":"API Reference \u2013 Synchronization and Thread Safety","text":"<p>The core implementation is not inherently thread-safe. Instead, it exposes a simple hook mechanism so callers can integrate with platform-specific synchronization (e.g. mutexes, critical sections, or RTOS primitives).</p> <p>This is optional: on single-threaded systems, you can ignore these hooks.</p>"},{"location":"api-sync/#lock-and-unlock-callbacks","title":"Lock and Unlock Callbacks","text":"<p>The header defines function pointer types:</p> <pre><code>typedef void (*mempool_lock_fn)(void *ctx);\ntypedef void (*mempool_unlock_fn)(void *ctx);\n</code></pre> <p>The <code>ctx</code> argument is an opaque pointer that is passed through from the pool to the callback, typically pointing to a mutex or wrapper structure.</p>"},{"location":"api-sync/#mempool_set_sync","title":"<code>mempool_set_sync</code>","text":"<pre><code>mempool_error_t mempool_set_sync(mempool_t      *pool,\n                                 mempool_lock_fn lock,\n                                 mempool_unlock_fn unlock,\n                                 void           *user_ctx);\n</code></pre>"},{"location":"api-sync/#parameters","title":"Parameters","text":"<ul> <li><code>pool</code> \u2013 Pool handle.</li> <li><code>lock</code> \u2013 Function called before entering a critical section.</li> <li><code>unlock</code> \u2013 Function called after leaving a critical section.</li> <li><code>user_ctx</code> \u2013 Pointer passed to both callbacks as <code>ctx</code>.</li> </ul>"},{"location":"api-sync/#behavior","title":"Behavior","text":"<ul> <li>If both <code>lock</code> and <code>unlock</code> are non-<code>NULL</code>, synchronization is enabled:</li> <li><code>lock(user_ctx)</code> is called before modifying internal pool state.</li> <li><code>unlock(user_ctx)</code> is called afterwards.</li> <li>If either <code>lock</code> or <code>unlock</code> is <code>NULL</code>, synchronization is disabled.</li> </ul>"},{"location":"api-sync/#returns","title":"Returns","text":"<ul> <li><code>MEMPOOL_OK</code> on success.</li> <li><code>MEMPOOL_ERR_NULL_PTR</code> if <code>pool</code> is <code>NULL</code>.</li> <li><code>MEMPOOL_ERR_NOT_INITIALIZED</code> if the pool is not initialized.</li> </ul>"},{"location":"api-sync/#example-using-pthread_mutex_t","title":"Example \u2013 Using <code>pthread_mutex_t</code>","text":"<pre><code>#include &lt;pthread.h&gt;\n#include \"mempool.h\"\n\ntypedef struct {\n    pthread_mutex_t mutex;\n} pool_lock_ctx_t;\n\nstatic void pool_lock(void *ctx)\n{\n    pool_lock_ctx_t *c = (pool_lock_ctx_t *)ctx;\n    (void)pthread_mutex_lock(&amp;c-&gt;mutex);\n}\n\nstatic void pool_unlock(void *ctx)\n{\n    pool_lock_ctx_t *c = (pool_lock_ctx_t *)ctx;\n    (void)pthread_mutex_unlock(&amp;c-&gt;mutex);\n}\n\nstatic uint8_t state_buf[MEMPOOL_STATE_SIZE];\nstatic uint8_t pool_buf[4096U];\n\nstatic pool_lock_ctx_t lock_ctx = { PTHREAD_MUTEX_INITIALIZER };\n\nvoid init_thread_safe_pool(void)\n{\n    mempool_t *pool = NULL;\n\n    (void)mempool_init(state_buf, sizeof(state_buf),\n                       pool_buf,  sizeof(pool_buf),\n                       64U, 8U, &amp;pool);\n\n    (void)mempool_set_sync(pool, pool_lock, pool_unlock, &amp;lock_ctx);\n}\n</code></pre> <p>All subsequent calls to <code>mempool_alloc</code>, <code>mempool_free</code>, <code>mempool_reset</code>, and <code>mempool_get_stats</code> on this <code>pool</code> will be wrapped in <code>pool_lock</code> / <code>pool_unlock</code> calls.</p>"},{"location":"api-sync/#notes-and-recommendations","title":"Notes and Recommendations","text":"<ul> <li>Synchronization is per pool. If you have multiple pools sharing the same   low-level resource, use a shared context that locks all of them consistently.</li> <li>On very small embedded systems, <code>lock</code>/<code>unlock</code> can simply disable/enable   interrupts or enter/exit a critical section.</li> <li>For maximum determinism, keep the callback bodies short and bounded; avoid   calling unbounded or blocking APIs from inside lock/unlock.</li> </ul>"},{"location":"api-types/","title":"API Reference \u2013 Types and Error Codes","text":"<p>This page describes the public types exposed by the <code>mempool</code> header.</p>"},{"location":"api-types/#error-codes-mempool_error_t","title":"Error Codes \u2013 <code>mempool_error_t</code>","text":"<p>The library uses an enum for all return codes:</p> <pre><code>typedef enum {\n    MEMPOOL_OK = 0,\n    MEMPOOL_ERR_NULL_PTR = 1,\n    MEMPOOL_ERR_INVALID_SIZE = 2,\n    MEMPOOL_ERR_OUT_OF_MEMORY = 3,\n    MEMPOOL_ERR_INVALID_BLOCK = 4,\n    MEMPOOL_ERR_ALIGNMENT = 5,\n    MEMPOOL_ERR_DOUBLE_FREE = 6,\n    MEMPOOL_ERR_NOT_INITIALIZED = 7\n} mempool_error_t;\n</code></pre>"},{"location":"api-types/#summary","title":"Summary","text":"<ul> <li><code>MEMPOOL_OK</code> \u2013 Operation completed successfully.</li> <li><code>MEMPOOL_ERR_NULL_PTR</code> \u2013 One or more pointer arguments were <code>NULL</code>.</li> <li><code>MEMPOOL_ERR_INVALID_SIZE</code> \u2013 Buffer sizes or block size were invalid.</li> <li><code>MEMPOOL_ERR_OUT_OF_MEMORY</code> \u2013 Pool is exhausted; no more blocks can be allocated.</li> <li><code>MEMPOOL_ERR_INVALID_BLOCK</code> \u2013 Pointer does not belong to this pool or is misaligned.</li> <li><code>MEMPOOL_ERR_ALIGNMENT</code> \u2013 Alignment parameter or buffer alignment is invalid.</li> <li><code>MEMPOOL_ERR_DOUBLE_FREE</code> \u2013 Block has already been freed or was never allocated.</li> <li><code>MEMPOOL_ERR_NOT_INITIALIZED</code> \u2013 Operation attempted on a non-initialized pool.</li> </ul>"},{"location":"api-types/#opaque-pool-handle-mempool_t","title":"Opaque Pool Handle \u2013 <code>mempool_t</code>","text":"<p>The actual pool control structure is private to the implementation.</p> <p>The header exposes:</p> <pre><code>typedef struct mempool mempool_t;\n</code></pre> <p>Callers never allocate <code>mempool_t</code> directly. Instead, they provide a state buffer to <code>mempool_init</code>, which constructs an internal <code>struct mempool</code> in-place and returns a <code>mempool_t*</code> handle.</p>"},{"location":"api-types/#statistics-mempool_stats_t","title":"Statistics \u2013 <code>mempool_stats_t</code>","text":"<p>The library tracks usage statistics to support monitoring and debugging:</p> <pre><code>typedef struct {\n    uint32_t total_blocks;  /* Configured total blocks in the pool      */\n    uint32_t used_blocks;   /* Currently allocated blocks              */\n    uint32_t free_blocks;   /* Currently free blocks                   */\n    uint32_t peak_usage;    /* Maximum simultaneously used blocks      */\n    uint32_t alloc_count;   /* Cumulative number of successful allocs  */\n    uint32_t free_count;    /* Cumulative number of successful frees   */\n    uint32_t block_size;    /* Size of each block in bytes             */\n} mempool_stats_t;\n</code></pre> <p>These values are available via <code>mempool_get_stats</code>.</p>"},{"location":"api-types/#synchronization-hooks","title":"Synchronization Hooks","text":"<p>The library does not perform any locking internally by default, but it exposes a simple mechanism to integrate with platform-specific synchronization.</p>"},{"location":"api-types/#lockunlock-callback-types","title":"Lock/Unlock Callback Types","text":"<pre><code>typedef void (*mempool_lock_fn)(void *ctx);\ntypedef void (*mempool_unlock_fn)(void *ctx);\n</code></pre>"},{"location":"api-types/#synchronization-descriptor","title":"Synchronization Descriptor","text":"<pre><code>typedef struct {\n    mempool_lock_fn   lock;\n    mempool_unlock_fn unlock;\n    void             *user_ctx;\n} mempool_sync_t;\n</code></pre> <p>Callers configure synchronization using <code>mempool_set_sync</code>, described in API \u2013 Synchronization &amp; Thread Safety.</p> <p>When enabled, the library calls these hooks around critical sections that modify the pool's internal state.</p>"},{"location":"building/","title":"Building and Running Tests","text":"<p>The repository supports both CMake and a traditional Makefile.</p>"},{"location":"building/#using-cmake-recommended-for-host","title":"Using CMake (Recommended for Host)","text":"<p>From the repository root:</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Debug\nmake\nctest --output-on-failure\n</code></pre>"},{"location":"building/#cmake-options","title":"CMake Options","text":"<p>The project exposes several options to help with verification on host:</p> <ul> <li> <p><code>MEMPOOL_ENABLE_SANITIZERS</code> (ON/OFF)   Enables AddressSanitizer + UndefinedBehaviorSanitizer for GCC/Clang builds.</p> </li> <li> <p><code>MEMPOOL_ENABLE_TSAN</code> (ON/OFF)   Enables ThreadSanitizer. This is mutually exclusive with <code>MEMPOOL_ENABLE_SANITIZERS</code>.</p> </li> <li> <p><code>MEMPOOL_ENABLE_COVERAGE</code> (ON/OFF)   Adds coverage flags (e.g. <code>--coverage -O0</code>) so you can run <code>gcov</code>/<code>lcov</code> or <code>llvm-cov</code>.</p> </li> </ul> <p>Example:</p> <pre><code>cmake -B build -S . -DCMAKE_BUILD_TYPE=Debug       -DMEMPOOL_ENABLE_SANITIZERS=ON       -DMEMPOOL_ENABLE_COVERAGE=ON\ncmake --build build -- -j\"$(nproc)\"\ncd build &amp;&amp; ctest --output-on-failure\n</code></pre> <p>This builds:</p> <ul> <li><code>libmempool.a</code> \u2013 static library</li> <li><code>mempool_ctest</code> \u2013 C test harness</li> <li><code>mempool_gtest</code> \u2013 GoogleTest C++ test binary</li> <li><code>example_basic</code>, <code>example_embedded</code>, <code>example_stress</code> \u2013 sample programs</li> </ul>"},{"location":"building/#using-make","title":"Using Make","text":"<p>For environments where CMake is not convenient, a simple Makefile is provided.</p> <p>Typical usage:</p> <pre><code>make           # builds library + C test harness\nmake test      # runs the C test harness\nmake examples  # builds example binaries\nmake clean     # cleans build artefacts\n</code></pre> <p>Targets may vary slightly depending on your Makefile version; see the comments in <code>Makefile</code>.</p>"},{"location":"building/#running-the-test-harness-and-examples","title":"Running the Test Harness and Examples","text":"<p>After building with CMake:</p> <pre><code>cd build\n./mempool_ctest       # C harness\n./mempool_gtest       # GoogleTest-based tests\n\n./example_basic       # basic usage demo\n./example_embedded    # embedded-style packet buffer demo\n./example_stress      # stress test demo\n</code></pre> <p>If sanitizers are enabled, they will report issues on the console if anything suspicious is detected.</p>"},{"location":"building/#static-analysis-and-coverage","title":"Static Analysis and Coverage","text":"<p>The repository is set up so CI can run:</p> <ul> <li><code>cppcheck</code> on the C sources and examples</li> <li>Sanitizer-instrumented builds (Address, Undefined, and optional Thread)</li> <li>Coverage instrumentation via <code>--coverage</code></li> </ul> <p>For local runs:</p> <pre><code># Example cppcheck invocation for C code\ncppcheck   --suppress=missingIncludeSystem   --enable=all   --std=c11   --language=c   --inline-suppr   -Iinclude   src/ tests/*.c examples/*.c\n</code></pre> <p>See Safety &amp; Process \u2192 Development Plan for more detail on recommended verification steps.</p>"},{"location":"examples-basic/","title":"Examples \u2013 Basic Usage","text":"<p>This page shows a small, self-contained program that initializes a pool, allocates a few blocks, and prints basic statistics.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include \"mempool.h\"\n\n#define POOL_BYTES 4096U\n\nstatic uint8_t state_buf[MEMPOOL_STATE_SIZE] __attribute__((aligned(8)));\nstatic uint8_t pool_buf[POOL_BYTES]          __attribute__((aligned(8)));\n\nint main(void)\n{\n    mempool_t *pool = NULL;\n\n    if (mempool_state_size() &gt; sizeof(state_buf)) {\n        printf(\"State buffer too small (need %zu bytes)\\n\",\n               mempool_state_size());\n        return 1;\n    }\n\n    mempool_error_t err = mempool_init(\n        state_buf, sizeof(state_buf),\n        pool_buf, sizeof(pool_buf),\n        64U, 8U, &amp;pool\n    );\n    if (err != MEMPOOL_OK) {\n        printf(\"mempool_init failed: %s\\n\", mempool_strerror(err));\n        return 1;\n    }\n\n    mempool_stats_t stats;\n    (void)mempool_get_stats(pool, &amp;stats);\n    printf(\"Pool initialized: %u blocks of %u bytes\\n\",\n           stats.total_blocks, stats.block_size);\n\n    void *a = NULL;\n    void *b = NULL;\n\n    err = mempool_alloc(pool, &amp;a);\n    printf(\"alloc a -&gt; %s (ptr=%p)\\n\",\n           mempool_strerror(err), (void *)a);\n\n    err = mempool_alloc(pool, &amp;b);\n    printf(\"alloc b -&gt; %s (ptr=%p)\\n\",\n           mempool_strerror(err), (void *)b);\n\n    (void)mempool_get_stats(pool, &amp;stats);\n    printf(\"Used blocks: %u / %u (peak: %u)\\n\",\n           stats.used_blocks, stats.total_blocks, stats.peak_usage);\n\n    (void)mempool_free(pool, a);\n    (void)mempool_free(pool, b);\n\n    (void)mempool_get_stats(pool, &amp;stats);\n    printf(\"After free: used=%u free=%u\\n\",\n           stats.used_blocks, stats.free_blocks);\n\n    return 0;\n}\n</code></pre> <p>Compile and run (for example):</p> <pre><code>gcc -std=c11 -Wall -Wextra -Iinclude     examples/basic_usage.c src/mempool.c     -o example_basic\n./example_basic\n</code></pre>"},{"location":"examples-embedded/","title":"Examples \u2013 Embedded / Packet Buffers","text":"<p>A common pattern in embedded systems is to use a fixed pool of packet buffers or message objects that are recycled.</p> <p>The following example shows a simple packet structure allocated from a pool.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include \"mempool.h\"\n\n#define PACKET_SIZE 256U\n#define MAX_PACKETS 16U\n\ntypedef struct {\n    uint8_t  data[PACKET_SIZE];\n    uint32_t length;\n    uint32_t timestamp;\n} packet_t;\n\nstatic uint8_t state_buf[MEMPOOL_STATE_SIZE] __attribute__((aligned(8)));\nstatic uint8_t pool_buf[PACKET_SIZE * MAX_PACKETS] __attribute__((aligned(8)));\n\nint main(void)\n{\n    mempool_t *pool = NULL;\n\n    if (mempool_state_size() &gt; sizeof(state_buf)) {\n        /* configuration error */\n        return 1;\n    }\n\n    mempool_error_t err = mempool_init(\n        state_buf, sizeof(state_buf),\n        pool_buf, sizeof(pool_buf),\n        sizeof(packet_t), 8U,\n        &amp;pool\n    );\n    if (err != MEMPOOL_OK) {\n        printf(\"mempool_init failed: %s\\n\", mempool_strerror(err));\n        return 1;\n    }\n\n    packet_t *tx = NULL;\n    packet_t *rx = NULL;\n\n    (void)mempool_alloc(pool, (void **)&amp;tx);\n    (void)mempool_alloc(pool, (void **)&amp;rx);\n\n    if ((tx != NULL) &amp;&amp; (rx != NULL)) {\n        tx-&gt;length    = 128U;\n        tx-&gt;timestamp = 1000U;\n\n        rx-&gt;length    = 64U;\n        rx-&gt;timestamp = 1001U;\n\n        printf(\"TX length=%u RX length=%u\\n\",\n               (unsigned)tx-&gt;length, (unsigned)rx-&gt;length);\n    }\n\n    (void)mempool_free(pool, tx);\n    (void)mempool_free(pool, rx);\n\n    return 0;\n}\n</code></pre> <p>On a real embedded target, you would typically:</p> <ul> <li>place <code>state_buf</code> and <code>pool_buf</code> in specific memory sections,</li> <li>possibly align <code>pool_buf</code> for DMA,</li> <li>and integrate with your RTOS or scheduler.</li> </ul>"},{"location":"examples-stress/","title":"Examples \u2013 Stress &amp; Testing","text":"<p>The library ships with internal stress tests as part of the test harness, but you can also create a very simple stress program for your own environment.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include \"mempool.h\"\n\n#define POOL_BYTES 8192U\n#define BLOCK_SIZE 64U\n\nstatic uint8_t state_buf[MEMPOOL_STATE_SIZE] __attribute__((aligned(8)));\nstatic uint8_t pool_buf[POOL_BYTES]          __attribute__((aligned(8)));\n\nint main(void)\n{\n    mempool_t *pool = NULL;\n\n    if (mempool_state_size() &gt; sizeof(state_buf)) {\n        printf(\"State buffer too small.\\n\");\n        return 1;\n    }\n\n    if (mempool_init(state_buf, sizeof(state_buf),\n                     pool_buf, sizeof(pool_buf),\n                     BLOCK_SIZE, 8U,\n                     &amp;pool) != MEMPOOL_OK) {\n        printf(\"Failed to init pool.\\n\");\n        return 1;\n    }\n\n    const uint32_t cycles = 1000U;\n    const uint32_t max_blocks = 128U;\n\n    void *blocks[128];\n    for (uint32_t i = 0U; i &lt; max_blocks; i++) {\n        blocks[i] = NULL;\n    }\n\n    for (uint32_t c = 0U; c &lt; cycles; c++) {\n        /* allocate as many as we can */\n        uint32_t allocated = 0U;\n        for (uint32_t i = 0U; i &lt; max_blocks; i++) {\n            if (mempool_alloc(pool, &amp;blocks[i]) == MEMPOOL_OK) {\n                allocated++;\n            } else {\n                break;\n            }\n        }\n\n        /* free them again */\n        for (uint32_t i = 0U; i &lt; max_blocks; i++) {\n            if (blocks[i] != NULL) {\n                (void)mempool_free(pool, blocks[i]);\n                blocks[i] = NULL;\n            }\n        }\n    }\n\n    mempool_stats_t stats;\n    (void)mempool_get_stats(pool, &amp;stats);\n\n    printf(\"Stress done. total=%u used=%u free=%u peak=%u alloc_count=%u free_count=%u\\n\",\n           stats.total_blocks,\n           stats.used_blocks,\n           stats.free_blocks,\n           stats.peak_usage,\n           stats.alloc_count,\n           stats.free_count);\n\n    return 0;\n}\n</code></pre> <p>This example is intentionally simple. For deeper stress testing, consider:</p> <ul> <li>mixing random allocation and free patterns,</li> <li>running under sanitizers (ASan, UBSan, TSAN),</li> <li>integrating with your system's typical data-flow paths.</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This page shows how to integrate <code>mempool</code> into a project and use it in a minimal way.</p>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>C11-capable compiler (GCC, Clang, or similar)</li> <li>Basic C standard library (<code>stddef.h</code>, <code>stdint.h</code>, <code>stdbool.h</code>)</li> <li>No OS or dynamic memory required</li> </ul> <p>Optional but recommended for host development:</p> <ul> <li>CMake (for the reference build)</li> <li>GoogleTest (fetched automatically by CMake for the C++ tests)</li> <li>cppcheck, sanitizers, and coverage tools</li> </ul>"},{"location":"getting-started/#basic-integration-model","title":"Basic Integration Model","text":"<p>The library does not allocate memory internally.</p> <p>Instead, the caller provides:</p> <ol> <li>A state buffer to hold the opaque <code>mempool_t</code> state.</li> <li>A pool buffer to hold the fixed-size blocks.</li> </ol> <p>At runtime you:</p> <ol> <li>Call <code>mempool_state_size()</code> to learn how many bytes the state needs.</li> <li>Allocate a state buffer (static array, global, or from another allocator).</li> <li>Allocate a pool buffer for the actual blocks.</li> <li>Call <code>mempool_init(...)</code> to initialize the pool and obtain a <code>mempool_t*</code> handle.</li> <li>Use <code>mempool_alloc</code> / <code>mempool_free</code> to manage blocks.</li> </ol>"},{"location":"getting-started/#minimal-example","title":"Minimal Example","text":"<pre><code>#include \"mempool.h\"\n\n#define POOL_BYTES 4096U\n\n/* Caller-provided storage */\nstatic uint8_t state_buf[MEMPOOL_STATE_SIZE] __attribute__((aligned(8)));\nstatic uint8_t pool_buf[POOL_BYTES]          __attribute__((aligned(8)));\n\nvoid init_my_pool(void)\n{\n    mempool_t *pool = NULL;\n\n    /* Sanity check: make sure our state buffer is large enough */\n    if (mempool_state_size() &gt; sizeof(state_buf)) {\n        /* Configuration error: adjust MEMPOOL_STATE_SIZE or state_buf size */\n        /* handle error (assert, log, etc.) */\n        return;\n    }\n\n    mempool_error_t err = mempool_init(\n        state_buf, sizeof(state_buf),   /* state buffer */\n        pool_buf,  sizeof(pool_buf),    /* pool buffer */\n        64U,                            /* block size */\n        8U,                             /* alignment (power of two) */\n        &amp;pool                           /* out: pool handle */\n    );\n\n    if (err != MEMPOOL_OK) {\n        /* handle error */\n        return;\n    }\n\n    /* Allocate a block */\n    void *block = NULL;\n    err = mempool_alloc(pool, &amp;block);\n    if (err == MEMPOOL_OK) {\n        /* Use the block... */\n\n        /* Return it to the pool */\n        (void)mempool_free(pool, block);\n    }\n}\n</code></pre>"},{"location":"getting-started/#state-buffer-sizing","title":"State Buffer Sizing","text":"<p>The header exposes:</p> <pre><code>size_t mempool_state_size(void);\n</code></pre> <p>At compile time you typically define:</p> <pre><code>#ifndef MEMPOOL_STATE_SIZE\n#define MEMPOOL_STATE_SIZE 128U /* or larger */\n#endif\n</code></pre> <p>Then allocate a buffer of that size:</p> <pre><code>static uint8_t state_buf[MEMPOOL_STATE_SIZE];\n</code></pre> <p>At runtime, <code>mempool_state_size()</code> returns the actual bytes required by the implementation. You must check that <code>mempool_state_size() &lt;= MEMPOOL_STATE_SIZE</code> and treat a mismatch as a configuration error.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>See Building to compile and run tests.</li> <li>See API Reference for details on functions and error handling.</li> <li>See Examples for more concrete usage patterns.</li> </ul>"},{"location":"requirements/","title":"Requirements","text":"<p>This document captures functional and non-functional requirements for the <code>mempool</code> library. Identifiers (<code>R-xxx</code>) are used in traceability.</p>"},{"location":"requirements/#functional-requirements","title":"Functional Requirements","text":"<ul> <li> <p>R-001 \u2013 No Dynamic Allocation   The library must not call <code>malloc</code>, <code>free</code>, <code>realloc</code>, or any equivalent   dynamic memory API. All memory must be provided by the caller.</p> </li> <li> <p>R-002 \u2013 Deterministic Allocation and Free <code>mempool_alloc</code> and <code>mempool_free</code> shall execute in O(1) time with respect   to the number of blocks in the pool.</p> </li> <li> <p>R-003 \u2013 Fixed-Size Blocks   Each pool instance shall manage fixed-size blocks of a single block size.</p> </li> <li> <p>R-004 \u2013 Alignment Control   The caller shall be able to specify an alignment (power of two) for blocks   and the pool buffer. Misaligned buffers or invalid alignment values shall   be rejected.</p> </li> <li> <p>R-005 \u2013 Explicit Initialization   All pool operations shall fail with <code>MEMPOOL_ERR_NOT_INITIALIZED</code> if the   pool has not been successfully initialized by <code>mempool_init</code>.</p> </li> <li> <p>R-006 \u2013 Error Reporting   Every public function shall return a <code>mempool_error_t</code> that indicates   success or the reason for failure.</p> </li> <li> <p>R-007 \u2013 Double-Free Detection   The library shall detect an attempt to free a block that has already been   freed and return <code>MEMPOOL_ERR_DOUBLE_FREE</code>.</p> </li> <li> <p>R-008 \u2013 Invalid Block Detection   The library shall detect pointers that do not belong to the pool or are   incorrectly aligned, and return <code>MEMPOOL_ERR_INVALID_BLOCK</code>.</p> </li> <li> <p>R-009 \u2013 Statistics Reporting   The library shall maintain usage statistics (total, used, free, peak,   allocation count, free count, block size) and provide them via   <code>mempool_get_stats</code>.</p> </li> <li> <p>R-010 \u2013 Reset Support   The library shall provide a way to reset a pool to its initial state,   returning all blocks to the free list and resetting statistics.</p> </li> <li> <p>R-011 \u2013 Contains Check   The library shall provide a way to check whether a pointer lies within   the address range managed by a given pool.</p> </li> <li> <p>R-012 \u2013 Human-Readable Error Strings   The library shall provide a function <code>mempool_strerror</code> to translate   error codes to human-readable strings.</p> </li> <li> <p>R-013 \u2013 Optional Synchronization Hooks   The library shall allow the caller to configure synchronization callbacks   (<code>mempool_set_sync</code>) so that operations can be made thread-safe when needed.</p> </li> </ul>"},{"location":"requirements/#non-functional-requirements","title":"Non-Functional Requirements","text":"<ul> <li> <p>N-001 \u2013 Portability   The code shall be written in portable C11 and not rely on OS-specific APIs   in the core implementation.</p> </li> <li> <p>N-002 \u2013 Predictable Behavior on Error   Functions shall never leave the pool in an inconsistent state if they   return an error.</p> </li> <li> <p>N-003 \u2013 Testability   The code base shall be structured so that unit tests can run on host   toolchains without special hardware.</p> </li> <li> <p>N-004 \u2013 Diagnostic Support   The repository shall include tests, example programs, and diagnostic   building blocks (statistics, error strings) to ease integration and   troubleshooting.</p> </li> <li> <p>N-005 \u2013 Static and Dynamic Analysis Friendly   The project shall be compatible with static analysis and sanitizers on   host builds, without requiring proprietary tools.</p> </li> </ul>"},{"location":"traceability/","title":"Traceability Overview","text":"<p>This document provides a high-level mapping between requirements, implementation areas, and tests. It is not intended to be exhaustive, but to give a clear starting point for a safety case.</p>"},{"location":"traceability/#legend","title":"Legend","text":"<ul> <li>Req \u2013 Requirement ID from Requirements</li> <li>Implementation \u2013 Files / functions where the requirement is primarily addressed</li> <li>Tests \u2013 C tests and GoogleTest cases that exercise the requirement</li> </ul>"},{"location":"traceability/#mapping-table","title":"Mapping Table","text":"Req Implementation Tests R-001 <code>src/mempool.c</code> (no dynamic allocation) C harness, all tests; GTest allocation tests R-002 <code>mempool_alloc</code>, <code>mempool_free</code> <code>AllocFreeAndStats</code>, stress tests R-003 <code>mempool_init</code> block size config initialization tests, multi-pool tests R-004 <code>mempool_init</code> alignment checks alignment and misalignment tests R-005 <code>initialized</code> flag and checks tests calling APIs before initialization R-006 all public functions return enum all tests (error paths asserted) R-007 bitmap tracking in <code>mempool_free</code> double-free detection tests R-008 range/alignment checks in <code>mempool_free</code> invalid pointer tests R-009 <code>mempool_stats_t</code>, <code>mempool_get_stats</code> stats and peak usage tests R-010 <code>mempool_reset</code> reset behavior tests R-011 <code>mempool_contains</code> contains tests and multi-pool separation tests R-012 <code>mempool_strerror</code> error string tests R-013 <code>mempool_set_sync</code>, internal lock hooks multithreaded GTest cases N-001 use of C11, no OS deps inspection, host builds on GCC/Clang N-002 defensive checks / error codes error-path tests, static analysis N-003 separate tests / examples C harness, GoogleTest, examples N-004 stats, error strings, examples examples and API docs N-005 <code>cppcheck</code> / sanitizers setup CI configuration, dev plan <p>For more detail, see:</p> <ul> <li>Safety Manual</li> <li>Development Plan</li> <li>Verification Report Template</li> </ul>"},{"location":"safety/dev_plan/","title":"Development and Verification Plan (Free Tooling)","text":"<p>This document outlines a suggested development and verification flow for the <code>mempool</code> library using only free tools. It is intended as a guideline and can be adapted to local processes.</p>"},{"location":"safety/dev_plan/#source-control-and-reviews","title":"Source Control and Reviews","text":"<ul> <li>Maintain the code in a version-controlled repository (e.g. Git).</li> <li>Require code review for all non-trivial changes.</li> <li>Enforce that all changes run the full test and static analysis suite before   being merged to the main branch.</li> </ul>"},{"location":"safety/dev_plan/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Use C11 with strict warnings enabled (e.g. <code>-Wall -Wextra -Wpedantic</code>).</li> <li>Avoid non-portable extensions in the core implementation.</li> <li>Prefer simple control flow and bounded loops.</li> <li>Check all return codes from library and system calls in tests and examples.</li> </ul>"},{"location":"safety/dev_plan/#static-analysis","title":"Static Analysis","text":"<ul> <li>Run <code>cppcheck</code> on C sources, tests, and examples.</li> </ul> <p>Example command:</p> <pre><code>cppcheck   --suppress=missingIncludeSystem   --enable=all   --std=c11   --language=c   --inline-suppr   -Iinclude   src/ tests/*.c examples/*.c\n</code></pre> <ul> <li>Optionally, use <code>clang-tidy</code> with a suitable configuration for additional   diagnostics on host platforms.</li> </ul>"},{"location":"safety/dev_plan/#dynamic-analysis-sanitizers","title":"Dynamic Analysis (Sanitizers)","text":"<p>On host toolchains (GCC/Clang), build the library and tests with:</p> <ul> <li>AddressSanitizer (ASan)</li> <li>UndefinedBehaviorSanitizer (UBSan)</li> <li>ThreadSanitizer (TSAN) for multithreaded tests</li> </ul> <p>CMake options are provided to enable these.</p> <p>Recommended steps:</p> <ol> <li>Configure a Debug build with sanitizers:</li> </ol> <pre><code>cmake -B build -S . -DCMAKE_BUILD_TYPE=Debug          -DMEMPOOL_ENABLE_SANITIZERS=ON\ncmake --build build\ncd build &amp;&amp; ctest --output-on-failure\n</code></pre> <ol> <li>For TSAN runs (mutually exclusive with ASan/UBSan):</li> </ol> <pre><code>cmake -B build-tsan -S . -DCMAKE_BUILD_TYPE=Debug          -DMEMPOOL_ENABLE_SANITIZERS=OFF          -DMEMPOOL_ENABLE_TSAN=ON\ncmake --build build-tsan\ncd build-tsan &amp;&amp; ctest --output-on-failure\n</code></pre>"},{"location":"safety/dev_plan/#code-coverage","title":"Code Coverage","text":"<ul> <li>Build with coverage flags on host (through CMake or manual flags).</li> <li>Run the full test suite.</li> <li>Use <code>gcov</code>/<code>lcov</code> or <code>llvm-cov</code> to generate coverage reports.</li> <li>Aim to achieve high coverage on the core library and critical error paths.</li> </ul> <p>Example (conceptual):</p> <pre><code># Configure with coverage\ncmake -B build-cov -S . -DCMAKE_BUILD_TYPE=Debug       -DMEMPOOL_ENABLE_COVERAGE=ON\ncmake --build build-cov\ncd build-cov &amp;&amp; ctest\n\n# Run coverage tools (commands depend on your tool choice)\n</code></pre>"},{"location":"safety/dev_plan/#continuous-integration","title":"Continuous Integration","text":"<p>The provided CI configuration (GitHub Actions) demonstrates:</p> <ul> <li>Building with CMake.</li> <li>Running tests.</li> <li>Running <code>cppcheck</code> on the C source, tests, and examples.</li> </ul> <p>Users can extend this with:</p> <ul> <li>Coverage upload (e.g. to Codecov),</li> <li>Additional static analysis steps,</li> <li>Platform-specific builds as needed.</li> </ul>"},{"location":"safety/dev_plan/#release-checklist","title":"Release Checklist","text":"<p>For each tagged release, it is recommended to:</p> <ol> <li>Run the full test suite (C harness + GoogleTest).</li> <li>Run static analysis on the code base.</li> <li>Run sanitizer-instrumented builds on host.</li> <li>Generate and inspect coverage reports.</li> <li>Document results and remaining open issues in the    Verification Report.</li> <li>Update the changelog with a summary of changes and their impact.</li> </ol> <p>This document can be used as a basis for explaining the development approach in larger safety cases or process documentation.</p>"},{"location":"safety/safety_manual/","title":"Safety Manual (Integration Notes)","text":"<p>This document describes assumptions, intended use, and integration responsibilities for users of the <code>mempool</code> library in safety-related systems.</p>"},{"location":"safety/safety_manual/#intended-use","title":"Intended Use","text":"<ul> <li>Deterministic allocation of fixed-size blocks from a pre-allocated buffer.</li> <li>Use in embedded or real-time systems where dynamic memory allocation is restricted   or forbidden.</li> <li>Integration in both single-threaded and multi-threaded environments, with   synchronization provided by the caller where required.</li> </ul> <p>The library is not a general-purpose allocator and does not support variable-sized allocations or reallocation.</p>"},{"location":"safety/safety_manual/#non-intended-use","title":"Non-Intended Use","text":"<ul> <li>Managing variable-sized allocations.</li> <li>Use as a drop-in replacement for <code>malloc</code> / <code>free</code> without adaptation.</li> <li>Use without checking return codes.</li> <li>Use in systems where memory availability is assumed unlimited or unbounded.</li> </ul>"},{"location":"safety/safety_manual/#safety-assumptions","title":"Safety Assumptions","text":"<p>The following assumptions are made about the environment and integration:</p> <ul> <li>The caller provides valid, non-overlapping buffers for state and pool memory.</li> <li>The caller checks the return value of all public functions and handles error   codes appropriately.</li> <li>The caller does not use pointers after they have been freed, or after a   pool has been reset.</li> <li>For multi-threaded use, the caller configures appropriate synchronization   via <code>mempool_set_sync</code> or otherwise ensures exclusive access.</li> <li>The compiler and toolchain are configured with reasonable warnings enabled   and any reported issues are addressed.</li> </ul>"},{"location":"safety/safety_manual/#failure-modes-and-expected-behavior","title":"Failure Modes and Expected Behavior","text":""},{"location":"safety/safety_manual/#out-of-memory","title":"Out of Memory","text":"<ul> <li>Condition: No more blocks are available in the pool.</li> <li>Behavior: <code>mempool_alloc</code> returns <code>MEMPOOL_ERR_OUT_OF_MEMORY</code> and does not   modify the internal state beyond what is necessary to detect the condition.</li> <li>Integration note: The caller must handle this error; typical actions are to   shed load, log an error, or switch to a degraded mode.</li> </ul>"},{"location":"safety/safety_manual/#invalid-block","title":"Invalid Block","text":"<ul> <li>Condition: <code>mempool_free</code> is called with a pointer that does not belong to   the pool or is misaligned.</li> <li>Behavior: The function returns <code>MEMPOOL_ERR_INVALID_BLOCK</code>. Internal state   is not modified.</li> <li>Integration note: This indicates a programming error or memory corruption.   The system should treat this as a serious fault.</li> </ul>"},{"location":"safety/safety_manual/#double-free","title":"Double Free","text":"<ul> <li>Condition: <code>mempool_free</code> is called with a block that has already been freed   or with a pointer that was never allocated.</li> <li>Behavior: The function returns <code>MEMPOOL_ERR_DOUBLE_FREE</code>. Internal state is   not modified.</li> <li>Integration note: This indicates a programming error and may warrant a   failsafe reaction in safety-critical systems.</li> </ul>"},{"location":"safety/safety_manual/#not-initialized","title":"Not Initialized","text":"<ul> <li>Condition: Any API except <code>mempool_state_size</code> or <code>mempool_init</code> is called   on an uninitialized pool handle.</li> <li>Behavior: The function returns <code>MEMPOOL_ERR_NOT_INITIALIZED</code>.</li> <li>Integration note: Ensure proper initialization order and error handling   in the calling system.</li> </ul>"},{"location":"safety/safety_manual/#thread-safety","title":"Thread Safety","text":"<ul> <li>By default, the library does not perform any locking.</li> <li>When <code>mempool_set_sync</code> is used, the library calls user-provided <code>lock</code> /   <code>unlock</code> callbacks around critical sections.</li> <li>The correctness and performance of these callbacks are the responsibility   of the integrator.</li> <li>In systems where interrupts may access the pool, it is the integrator\u2019s   responsibility to ensure interrupt-safe usage (e.g. via critical sections).</li> </ul>"},{"location":"safety/safety_manual/#recommended-integration-practices","title":"Recommended Integration Practices","text":"<ul> <li>Perform initialization at startup and treat any failure as a configuration   or resource error.</li> <li>Avoid calling <code>mempool_reset</code> while other parts of the system may still hold   pointers into the pool.</li> <li>Use statistics (<code>mempool_get_stats</code>) to monitor pool usage and detect   near-exhaustion early.</li> <li>Consider separate pools for different classes of objects (e.g. packets,   control structures) to avoid interference.</li> </ul>"},{"location":"safety/safety_manual/#known-limitations","title":"Known Limitations","text":"<ul> <li>Only supports fixed-size blocks.</li> <li>No built-in integration with RTOS-specific primitives; must be provided   by the caller.</li> <li>Does not protect against misuse of returned pointers beyond the checks   described above.</li> </ul>"},{"location":"safety/safety_manual/#verification-and-validation","title":"Verification and Validation","text":"<p>The repository includes:</p> <ul> <li>A C-based test harness covering core behaviors and error paths.</li> <li>A GoogleTest-based C++ test suite, including multithreaded stress tests   when running on host platforms.</li> <li>CI configurations for:</li> <li>static analysis (<code>cppcheck</code>),</li> <li>sanitizer-instrumented builds (ASan, UBSan, optional TSAN),</li> <li>unit test execution.</li> </ul> <p>Users integrating this library into a larger system remain responsible for:</p> <ul> <li>verifying behavior in their specific environment,</li> <li>performing additional testing necessary for their safety goals,</li> <li>and deciding how to incorporate this component into their safety case.</li> </ul>"},{"location":"safety/verification_report_template/","title":"Verification Report Template","text":"<p>This document is a template for recording verification and validation results for a specific release of the <code>mempool</code> library.</p> <p>Fill in one copy per release and store it under version control.</p>"},{"location":"safety/verification_report_template/#1-release-information","title":"1. Release Information","text":"<ul> <li>Component: mempool</li> <li>Version: <code>vX.Y.Z</code></li> <li>Date: <code>YYYY-MM-DD</code></li> <li>Commit ID: <code>&lt;git commit hash&gt;</code></li> <li>Compiler / Toolchain: <code>&lt;e.g. GCC 13, Clang 17&gt;</code></li> <li>Platforms Tested: <code>&lt;e.g. x86_64 Linux, ARM cross-compile&gt;</code></li> </ul>"},{"location":"safety/verification_report_template/#2-summary","title":"2. Summary","text":"<p>Brief summary of the verification activities for this release:</p> <ul> <li>Tests executed</li> <li>Static analysis runs</li> <li>Sanitizers / dynamic checks</li> <li>Coverage status</li> <li>Any deviations from the plan</li> </ul>"},{"location":"safety/verification_report_template/#3-test-results","title":"3. Test Results","text":""},{"location":"safety/verification_report_template/#31-c-test-harness","title":"3.1 C Test Harness","text":"<ul> <li>Binary: <code>mempool_ctest</code></li> <li>Command: <code>./mempool_ctest</code></li> </ul> Result Notes Pass/Fail Describe outcome and any notable observations"},{"location":"safety/verification_report_template/#32-googletest-suite","title":"3.2 GoogleTest Suite","text":"<ul> <li>Binary: <code>mempool_gtest</code></li> <li>Command: <code>./mempool_gtest</code></li> </ul> Result Notes Pass/Fail Describe outcome and any notable observations"},{"location":"safety/verification_report_template/#33-additional-target-specific-tests","title":"3.3 Additional / Target-Specific Tests","text":"<p>Describe any hardware or target-specific tests performed:</p> <ul> <li>Test name:</li> <li>Platform:</li> <li>Procedure:</li> <li>Result:</li> </ul>"},{"location":"safety/verification_report_template/#4-static-analysis","title":"4. Static Analysis","text":""},{"location":"safety/verification_report_template/#41-cppcheck","title":"4.1 cppcheck","text":"<ul> <li>Version: <code>&lt;version&gt;</code></li> <li>Command:</li> </ul> <pre><code>cppcheck --suppress=missingIncludeSystem --enable=all --std=c11 --language=c --inline-suppr -Iinclude src/ tests/*.c examples/*.c\n</code></pre> <ul> <li>Result: <code>&lt;Pass/Fail&gt;</code></li> <li>Notable findings and resolutions:</li> </ul>"},{"location":"safety/verification_report_template/#42-other-tools-optional","title":"4.2 Other Tools (Optional)","text":"<p>E.g. <code>clang-tidy</code>, other static analyzers.</p> <ul> <li>Tool:</li> <li>Version:</li> <li>Configuration:</li> <li>Result:</li> <li>Notable findings:</li> </ul>"},{"location":"safety/verification_report_template/#5-dynamic-analysis-sanitizers","title":"5. Dynamic Analysis (Sanitizers)","text":"<p>Describe AddressSanitizer, UndefinedBehaviorSanitizer, and ThreadSanitizer runs, if applicable.</p> <ul> <li>Build configuration:</li> <li>Commands:</li> <li>Result:</li> <li>Notable findings:</li> </ul>"},{"location":"safety/verification_report_template/#6-code-coverage","title":"6. Code Coverage","text":"<p>Summarize coverage results:</p> <ul> <li>Tool:</li> <li>Commands:</li> <li>Overall coverage (%):</li> <li>Coverage on critical files:</li> <li>Notable gaps and justification:</li> </ul>"},{"location":"safety/verification_report_template/#7-known-issues-and-limitations","title":"7. Known Issues and Limitations","text":"<p>List any open issues, limitations, or deviations from requirements that are known at the time of release.</p> <ul> <li>ID / reference:</li> <li>Description:</li> <li>Impact:</li> <li>Planned resolution:</li> </ul>"},{"location":"safety/verification_report_template/#8-conclusion","title":"8. Conclusion","text":"<p>Summarize whether the component is considered suitable for release under the defined process, including any restrictions or additional steps required for specific safety use cases.</p> <ul> <li>Overall assessment:</li> <li>Additional notes:</li> </ul>"},{"location":"safety/verification_report_template/#9-approval-if-applicable","title":"9. Approval (If Applicable)","text":"<ul> <li>Prepared by: <code>Name, Role, Date</code></li> <li>Reviewed by: <code>Name, Role, Date</code></li> <li>Approved by: <code>Name, Role, Date</code></li> </ul>"}]}